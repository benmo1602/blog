###  19. 对闭包的理解、工程中闭包使用场景:

闭包是在一个函数作用于内 访问函数内的私有变量 

### 	es6之前的模仿块级作用域、递归调用问题

1.  返回值  vue 的 data

2. 函数赋值

3. 函数参数

4. IIFE ( 自执行函数)

5. 循环赋值 （解决 for 中let 作用 ）

6. getter 、 setter 

   ```
   function fn(){
       var name='hello'
       setName=function(n){
           name = n;
       }
       getName=function(){
           return name;
       }
   
       //将setName，getName作为对象的属性返回
       return {
           setName:setName,
           getName:getName
       }
   }
   var fn1 = fn();//返回对象，属性setName和getName是两个函数
   console.log(fn1.getName());//getter
   fn1.setName('world');//setter修改闭包里面的name
   console.log(fn1.getName());//getter
   ```

   7. 迭代器（执行一次函数 往下取一次值）
   8. 缓存





### 执行上下文 

- `全局执行上下文`： 代码开始执行时首先进入的环境。
- `函数执行上下文`：函数调用时，会开始执行函数中的代码。
- `eval执行上下文`：不建议使用，可忽略。

执行上下文的周期，分为两个阶段

#### 创建阶段

​	创建词法环境、生成变量对象（建立作用域链）、 确认this 指向 

#### 执行期上下文

	1. 创建AO对象
 	2. 找形参和变量声明， 将变量和形参作为AO属性名，值为undefined
 	3. 实参和形参统一
 	4. 在函数体找到函数声明， 值赋予函数体。

#### 执行阶段

​	变量赋值、函数引用及执行代码



##### 1. 变量对象

##### 2. 变量对象（vo）的创建过程

##### 3. 变量对象变为轰动对象

##### 4. 
