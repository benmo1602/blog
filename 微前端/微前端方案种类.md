###  微前端方案种类

**基座模式**：通过搭建基座、配置中心来管理子应用。如基于SIngle Spa的偏通用的乾坤方案，也有基于本身团队业务量身定制的方案。

**自组织模式**： 通过约定进行互调，但会遇到处理第三方依赖等问题。

**去中心模式**： 脱离基座模式，每个应用之间都可以彼此分享资源。如基于**Webpack 5 Module Federation**实现的[EMP微前端方案](https://github.com/efoxTeam/emp)，可以实现多个应用彼此共享资源分享。

### iframe

```text
iframe虽然基本能做到微前端所要做的所有事情，但它的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来开发体验、产品体验的问题。
```

### Web Components

```text
作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。

Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。
```

它的**三项主要技术**是指：

- **Custom elements（自定义元素）**：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。
- **Shadow DOM（影子DOM）**：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。
- **HTML templates（HTML模板）**： `<template>` 和 `<slot>` 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。

通过以上描述，再结合微前端的概念，我们来看看`Web Components`是如何做到微前端：

1. **技术栈无关**：`Web Components`是浏览器原生组件，那即是在任何框架中都可以使用。
2. **独立开发**：使用`Web Components`开发的应用无需与其他应用间产生任何关联。
3. **应用间隔离**： `Shadow DOM`的特性，各个引入的微应用间可以达到相互隔离的效果。

综上所述，`Web Components`是有能力以组件加载的方式将微应用整合在一起作为微前端的一种手段，但不幸的是，`Web Components`是浏览器的新特性，所以它的兼容性不是很好，如果有兼容性要求的项目还是无法使用，具体请查看[can i use](https://link.zhihu.com/?target=https%3A//caniuse.com/%3Fsearch%3DWebComponents)。

### ESM

`ESM`是`ES Module`的缩写，是`Ecma script 2015`中提出的一种前端模块化手段，那么，它又是如何做到微前端的呢？其实，微前端无外乎三大特性，`无技术栈限制`、`应用单独开发`，`多应用整合`，只要抓住了这三个特性，那就不难理解`ESM`如何做的了：

1. **无技术栈限制**：`ESM`加载的只是js内容，无论哪个框架，最终都要编译成js，因此，无论哪种框架，`ESM`都能加载。
2. **应用单独开发**： ESM只是js的一种规范，不会影响应用的开发模式。
3. **多应用整合**： 只要将微应用以`ESM`的方式暴露出来，就能正常加载。
4. **远程加载模块**: `ESM`能够直接请求`cdn`资源，这是它与生俱来的能力。

`ESM`是能做到微前端的核心思想，但是它也存在着**兼容性**这一大弊端，尽管`ESM`已经很优秀了，但是**大部分老版的浏览器**仍然无法直接使用，这也是babel等编译工具出现的原因，幸运的是，他可以通过`webpack`、`rollup`、`esbuild`、`snowpack`等编译工具成为兼容性的代码。

### qiankun

在微前端界，`qiankun`算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，那么`qiankun`到底有哪些特点呢，在其[官网](https://link.zhihu.com/?target=https%3A//qiankun.umijs.org/zh/guide)中我找到了如下概括：

- **基于**`single-spa`封装，提供了更加开箱即用的 API
- **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架
- **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单
- **样式隔离**，确保微应用之间样式互相不干扰
- **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突
- **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
- **umi 插件**，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统

除了最后一点拓展以外，微前端想要达到的效果都已经达到。

### EMP

[EMP](https://link.zhihu.com/?target=https%3A//github.com/efoxTeam/emp)是由欢聚时代业务中台自主研发的最年轻的**单页微前端解决方案**

- **基于**`Webpack5`的新特性`Module Federation`实现，达到**第三方依赖共享，减少不必要的代码引入**的目的，什么是[Module Federation](https://link.zhihu.com/?target=https%3A//juejin.cn/post/6895324456668495880)这里就不再赘述。
- **每个微应用独立部署运行**，并通过cdn的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于`Module Federation`的应用使用。并且此部分代码是远程引入，无需参与应用的打包。
- **动态更新微应用**：`EMP`是通过`cdn`加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。
- **去中心化**，每个微应用间都可以引入其他的微应用，无中心应用的概念。
- **跨技术栈组件式调用**，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅[官方文档](https://link.zhihu.com/?target=https%3A//github.com/efoxTeam/emp/blob/main/README-zh_CN.md)）。
- **按需加载**，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载。
- **应用间通信**，每一个应用都可以进行状态共享，就像在使用npm模块进行开发一样便捷。
- **生成对应技术栈模板**，它能像`cerate-react-app`一样，也能像`create-vue-app`一样，通过指令一键搭建好开发环境，减少开发者的负担。
- **远程拉取ts声明文件**，`emp-cli`中内置了拉取远程应用中代码声明文件的能力，让使用ts开发的开发者不再为代码报错而烦恼。

细心的小伙伴应该发现，`EMP`除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力，这是现有框架所不具备的优秀特性！